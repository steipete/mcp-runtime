import path from 'node:path';
import type { RawConfig, RawEntry, ServerDefinition } from '../../config.js';
import type { ToolMetadata } from '../generate/tools.js';
import { buildToolDoc } from '../list-detail-helpers.js';

export interface SkillTemplateInput {
  skillName: string;
  description: string;
  serverName: string;
  tools: ToolMetadata[];
  generator: { name: string; version: string };
  generatedAt: string;
}

export function normalizeSkillName(name: string): string {
  const normalized = name
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
  if (!normalized) {
    throw new Error('Skill name must contain at least one alphanumeric character.');
  }
  return normalized.length > 64 ? normalized.slice(0, 64).replace(/-+$/g, '') || normalized.slice(0, 64) : normalized;
}

export function normalizeSkillDescription(description: string | undefined, serverName: string): string {
  const trimmed = (description ?? '').replace(/\s+/g, ' ').trim();
  const fallback = `Use when you need to work with the ${serverName}.`;
  const base = trimmed.length > 0 ? trimmed : fallback;
  const withTrigger = /use when/i.test(base) ? base : `${fallback} ${base}`;
  return withTrigger.slice(0, 500).trim();
}

export function renderSkillMarkdown(input: SkillTemplateInput): string {
  const { skillName, description, serverName, tools } = input;
  const capabilityLines = buildCapabilityLines(tools);
  const capabilitiesSection =
    capabilityLines.length > 0
      ? `Capabilities:\n${capabilityLines.join('\n')}\n\nSee \`references/tools.md\` for full signatures and examples.\n\n`
      : '';
  return (
    `---\nname: ${yamlString(skillName)}\ndescription: ${yamlString(description)}\n---\n\n` +
    `Use this skill to work with the ${serverName} MCP server.\n\n` +
    capabilitiesSection +
    `Resources:\n` +
    `- \`assets/mcporter.json\` contains a ready-to-use MCPorter config for this server.\n` +
    `- \`references/tools.md\` lists tool signatures, flags, and examples.\n\n` +
    `Workflow:\n` +
    `1. Run \`mcporter list --config assets/mcporter.json ${serverName}\` when you need to refresh tool docs.\n` +
    `2. Invoke tools with \`mcporter call --config assets/mcporter.json ${serverName}.<tool> ...\`.\n` +
    `3. Prefer \`--output json\` when you need structured results.\n`
  );
}

const MAX_CAPABILITY_LENGTH = 120;

function buildCapabilityLines(tools: ToolMetadata[]): string[] {
  if (tools.length === 0) {
    return [];
  }
  const items = tools.map((entry) => {
    const toolName = entry.tool.name;
    const summary = summarizeToolDescription(entry.tool.description);
    if (!summary) {
      return `- \`${toolName}\``;
    }
    return `- \`${toolName}\` — ${summary}`;
  });
  return items;
}

function summarizeToolDescription(description: string | undefined): string | undefined {
  if (!description) {
    return undefined;
  }
  const trimmed = description.replace(/\s+/g, ' ').trim();
  if (!trimmed) {
    return undefined;
  }
  const sentenceMatch = /[.!?](?:\s|$)/.exec(trimmed);
  const sentenceEnd = sentenceMatch ? sentenceMatch.index + 1 : trimmed.length;
  const sentence = trimmed.slice(0, sentenceEnd);
  if (sentence.length <= MAX_CAPABILITY_LENGTH) {
    return sentence;
  }
  return `${sentence.slice(0, MAX_CAPABILITY_LENGTH - 3).trimEnd()}...`;
}

export function renderToolsMarkdown(input: SkillTemplateInput): string {
  const { serverName, tools, generator, generatedAt } = input;
  const header = [
    `# ${serverName} tools`,
    '',
    `Generated by ${generator.name}@${generator.version} on ${generatedAt}.`,
    '',
    `Use \`mcporter call --config assets/mcporter.json ${serverName}.<tool>\` to invoke tools.`,
    '',
  ];
  if (tools.length === 0) {
    return [...header, 'No tools were discovered for this server.'].join('\n');
  }

  const sections = tools.map((toolEntry) => {
    const tool = toolEntry.tool;
    const doc = buildToolDoc({
      serverName,
      toolName: tool.name,
      description: tool.description,
      outputSchema: tool.outputSchema,
      options: toolEntry.options,
      requiredOnly: true,
      colorize: false,
      exampleMaxLength: 120,
      flagExtras: [{ text: '--output <format>' }],
      wrapExampleExpression: true,
    });

    const lines: string[] = [`## ${tool.name}`, ''];
    if (tool.description) {
      lines.push(tool.description.trim(), '');
    }
    lines.push('Signature:', `\`${doc.tsSignature}\``, '');
    if (doc.flagUsage) {
      lines.push('Flags:', `\`${doc.flagUsage}\``, '');
    }
    if (doc.optionalSummary) {
      lines.push(doc.optionalSummary, '');
    }
    if (doc.optionDocs.length > 0) {
      lines.push('Parameters:');
      doc.optionDocs.forEach((optionDoc) => {
        lines.push(`- \`${optionDoc.flagLabel}\` — ${optionDoc.description}`);
      });
      lines.push('');
    }
    if (doc.examples.length > 0) {
      lines.push('Example:', `\`${doc.examples[0]}\``);
      lines.push('');
    }
    return lines.join('\n').trimEnd();
  });

  return [...header, ...sections].join('\n\n');
}

export function buildSkillConfig(definition: ServerDefinition): RawConfig {
  const entry: RawEntry = {
    description: definition.description,
    env: definition.env,
    auth: definition.auth,
    tokenCacheDir: definition.tokenCacheDir,
    clientName: definition.clientName,
    oauthRedirectUrl: definition.oauthRedirectUrl,
    oauthCommand: definition.oauthCommand ? { args: [...definition.oauthCommand.args] } : undefined,
    lifecycle: definition.lifecycle,
    logging: definition.logging,
  };

  if (definition.command.kind === 'http') {
    entry.url = definition.command.url.toString();
    if (definition.command.headers) {
      entry.headers = { ...definition.command.headers };
    }
  } else {
    const cwd = definition.command.cwd;
    const resolvedCommand = resolveIfRelative(definition.command.command, cwd);
    const resolvedArgs = definition.command.args.map((arg) => resolveIfRelative(arg, cwd));
    entry.command = [resolvedCommand, ...resolvedArgs];
  }

  return {
    mcpServers: {
      [definition.name]: entry,
    },
  };
}

function resolveIfRelative(value: string, cwd: string): string {
  if (!value) {
    return value;
  }
  if (path.isAbsolute(value)) {
    return value;
  }
  if (value.startsWith('./') || value.startsWith('../')) {
    return path.resolve(cwd, value);
  }
  return value;
}

function yamlString(value: string): string {
  const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  return `"${escaped}"`;
}
